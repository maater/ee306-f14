<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<style>
    body {background-color: white; color: black}
    h1, h2, h3 {text-align: center}
    p, li {orphans: 3; widows: 3}
    .figure {margin-top: 1em; margin-right: auto; margin-bottom: 1em; margin-left: auto; text-align: center}
    table {border-collapse: collapse; empty-cells: show; page-break-inside: avoid}
    td {border: 1px solid black; padding: 0.5em}
    th {border: 1px solid black; padding: 0.5em; font-weight: bold}
    code {font-family: monospace}
    ol {list-style-type: decimal; margin-top: .5em; margin-bottom: .5em}
    ol ol {list-style-type: lower-alpha}
  </style>

    <title>EE 306 - Problem Set 5</title>
  </head><body bgcolor="white">
    <center>
      <h2>Department of Electrical and Computer Engineering</h2>
      <h3>The University of Texas at Austin</h3>

    </center>
    EE 306, Fall 2014<br>
    Problem Set 5<br>
    Due: November 10th, before class<br>
    Aater Suleman, Instructor<br>
    TAs: Owais Khan, Cagri Eryilmaz and Chirag Sakhuja <br>

	<p>
      Instructions:
      <br>
      You are encouraged to work on the problem set in groups and turn
      in one problem set for the entire group. Remember to put all
      your names on the solution sheet.  Also, remember to put the name
      of the TA and the time for the discussion section you would like the problem
      set turned back to you. Show your work. <br>
    </p>

<br>
<ol>


<li><!-- Begin Question -->
 (Adapted from 6.16) Shown below are the partial contents of memory locations x3000 to x3006.<br><br>

<table border="1" align="center" bordercolor="#000000" style="background-color:#FFFFFF" width="600" cellpadding="3" cellspacing="1">
	<tr align="center">

		<td>&nbsp; </td>
		<td>15</td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>

		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td>0</td>

	</tr>
	<tr align="center">
		<td>x3000</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

	</tr>
	<tr align="center">
		<td>x3001</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>1</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>
		<td>1</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>1</td>
	</tr>
	<tr align="center">
		<td>x3002</td>

		<td>1</td>
		<td>0</td>

		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
	</tr>
	<tr align="center">
		<td>x3003</td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
	</tr>
	<tr align="center">
		<td>x3004</td>
		<td>1</td>

		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>

		<td>1</td>
		<td>0</td>
		<td>1</td>
	</tr>
	<tr align="center">
		<td>x3005</td>

		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>

		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
	</tr>
	<tr align="center">

		<td>x3006</td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
	</tr>

</table>

<br><br>

The PC contains the value x3000, and the RUN button is pushed.<br><br>
As the program executes, we keep track of all values loaded into the MAR. Such a record is often referred to as an address trace. It is shown below. <br><br>
<center>
<u><b>MAR Trace <br></b></u>
  x3000<br>
  x3005<br>

  x3001<br>

  x3002<br>
  x3006<br>
  x4001<br>
  x3003<br>
  x0021<br><br>

</center>
Your job: Fill in the missing bits in memory locations x3000 to x3006.
</li> <!-- End of Question --><br><br>

<li><!-- Begin Question -->
(Adapted from 9.2)
<ol type="a">

<li><p>How many <code>TRAP</code> service routines can be implemented in the LC-3? Why?</p></li>

<li><p>Why must a <code>RET</code> instruction be used to return from a <code>TRAP</code> routine? Why won't
a <code>BRnzp</code> (unconditional <code>BR</code>) instruction work instead?</p></li>

<li><p>How many accesses to memory are made during the processing of a <code>TRAP</code> instruction?</p></li>

</ol>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
<p>Assume that you have the following table in your program:</p>
<pre><code>
MASKS	.FILL x0001
	.FILL x0002
	.FILL x0004
	.FILL x0008
	.FILL x0010
	.FILL x0020
	.FILL x0040
	.FILL x0080
	.FILL x0100
	.FILL x0200
	.FILL x0400
	.FILL x0800
	.FILL x1000
	.FILL x2000
	.FILL x4000
	.FILL x8000
</code></pre>
<ol type="a">
<li>
<p>Write a subroutine <code>CLEAR</code> in LC-3 assembly language that clears
a bit in <code>R0</code> <em>using the table above</em>. The index of the bit
to clear is specified in <code>R1</code>. <code>R0</code> and <code>R1</code>
are inputs to the subroutine.</p>

</li>
<li>
<p>Write a similar subroutine <code>SET</code> that sets the specified bit instead of clearing it.</p>
</li>
<p>
Hint: You should remember to save and restore any registers your subroutine
uses (the "callee save" convention). Use the <code>RET</code> instruction as
the last instruction in your subroutine (<code>R7</code> contains the address
of where in the caller to return to.)
</p>
</ol>
</li><br/><!-- End of Question -->

<li><!-- Begin Question -->
<p>Suppose we are writing an algorithm to multiply the
elements of an array (unpacked, 16-bit 2's complement numbers), and we
are told that a subroutine "mult_all" exists which multiplies four
values, and returns the product.
The mult_all subroutine assumes the source operands are in R1, R2, R3,
R4, and returns the product in R0. For purposes of this assignment, let
us assume that the individual values are small enough that the result
will always fit in a 16-bit 2's complement register.</p>
<p>
Your job: Using this subroutine, write a program to multiply the set of
values contained in consecutive locations starting at location x6001.
The number of such values is contained in x6000. Store your result at location x7000. Assume there is at least one value in the array(i.e., M[x6000] is greater than 0).
</p><ol type="a">
<p>

Hint: Feel free to include in your program
</p><pre><code>
PTR	.FILL x6001
CNT	.FILL x6000
</code></pre><p></p>
</ol>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
(Adapted from 9.13)<br>The following program is supposed to
print the number 5 on the screen. It does not work. Why? Answer in no
more than ten words, please.
<pre><code>
	.ORIG	x3000
	JSR	A
	OUT			;TRAP  x21
	BRnzp	DONE
A	AND	R0,R0,#0
	ADD	R0,R0,#5
	JSR	B
	RET
DONE	HALT
ASCII	.FILL	x0030
B	LD	R1,ASCII
	ADD	R0,R0,R1
	RET
	.END
</code></pre>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
(Adapted from 8.16)<br>
What does the following LC-3 program do?
<pre><code>
	.ORIG X3000
	LD R0,ASCII
	LD R1,NEG
AGAIN	LDI R2,DSR
	BRzp AGAIN
	STI R0,DDR
	ADD R0,R0,#1
	ADD R2,R0,R1
	BRnp AGAIN
	HALT
ASCII	.FILL X0041
NEG	.FILL XFFB6
DSR	.FILL XFE04
DDR	.FILL XFE06
	.END
</code></pre>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
(Adapted from 9.5)<br>
The following LC-3 program is assembled and then executed. There are no assemble time or run-time errors. What is the output of this program?
Assume all registers are initialized to 0 before the program executes.
<pre><code>
	.ORIG X3000
	ST R0, X3007
	LEA R0, LABEL
	TRAP X22
	TRAP x25
LABEL	.STRINGZ "FUNKY"
LABEL2	.STRINGZ "HELLO WORLD"
	.END
</code></pre>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
The memory locations given below store students' exam scores in form of a linked list. Each node of the linked list uses three memory locations to store<br><br>
1. Address of the next node<br>
2. Starting address of the memory locations where name of the student is stored<br>
3. Starting address of the memory locations where the his/her exam score is stored<br><br>
in the given order. The first node is stored in locations x4000 ~ x4002. The ASCII code x0000 is used as a sentinel to indicate the end of the string. Both the name and exam score are stored as strings.<br>
Write down the student's name and score in the order that it appears in the list.

<pre><code>
    Address	    Contents
    x4000	    x4016
    x4001	    x4003
    x4002	    x4008
    x4003	    x004D
    x4004	    x0061
    x4005	    x0072
    x4006	    x0063
    x4007	    x0000
    x4008	    x0039
    x4009	    x0030
    x400A	    x0000
    x400B	    x0000
    x400C	    x4019
    x400D	    x401E
    x400E	    x004A
    x400F	    x0061
    x4010	    x0063
    x4011	    x006B
    x4012	    x0000
    x4013	    x0031
    x4014	    x0038
    x4015	    x0000
    x4016	    x400B
    x4017	    x400E
    X4018	    x4013
    x4019	    x004D
    x401A	    x0069
    x401B	    x006B
    x401C	    x0065
    x401D	    x0000
    x401E	    x0037
    x401F	    x0036
    x4020	    x0000
</code></pre>
</li><!-- End of Question --><br/>


<li><!-- Begin Question -->
	<ol type=a>
	  <li>The program below counts the number of zeros in a 16-bit word.  Fill in the missing blanks below to make it work.<br>
	    <pre>
	    .ORIG x3000
	    AND   R0, R0, #0
	    LD	  R1, SIXTEEN
	    LD	  R2, WORD
A	    BRn   B
	    ________________
B	    ________________
	    BRz   C
	    ________________
	    BR	  A	; note: BR = BRnzp
C	    ST	  R0, RESULT
	    HALT

SIXTEEN     .FILL #16
WORD	    .BLKW #1
RESULT	    .BLKW #1
	    .END</pre></li>
	  <li>After you have the correct answer above, what one instruction can you change (without adding any instructions)
	    that will make the program count the number of ones instead?</li>
	</ol>
</li> <!--	End of Question --> <br/>

<li><!-- Begin Question --> 

Suppose we use the unused opcode 1101 to specify a new instruction. We will require 3 states after decode (state 32) to complete the job. The control signals required to carry out the work of the new instruction are shown below. All control signals not shown below are 0.
<center>
	<img src=data_path.png width = 40%>
</center>
<ol type=a>
	<li> What does this new instruction do? </li>

	<li> There are two different formats for specifying the operands of this instruction. Fill them out below. </li>
	<center>
		<img src = inst_format.png width = 30%>
	</center>
</ol>

</li> <!--	End of Question --> <br/>
</ol></body></html>
