<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<style> 
    body {background-color: white; color: black}
    h1, h2, h3 {text-align: center}
    p, li {orphans: 3; widows: 3}
    .figure {margin-top: 1em; margin-right: auto; margin-bottom: 1em; margin-left: auto; text-align: center}
    table {border-collapse: collapse; empty-cells: show; page-break-inside: avoid}
    td {border: 1px solid black; padding: 0.5em}
    th {border: 1px solid black; padding: 0.5em; font-weight: bold}
    code {font-family: monospace}
    ol {list-style-type: decimal; margin-top: .5em; margin-bottom: .5em}
    ol ol {list-style-type: lower-alpha}
  </style> 
  
    <title>EE 306 - Problem Set 5</title>
  </head><body bgcolor="white">
    <center>
      <h2>Department of Electrical and Computer Engineering</h2>
      <h3>The University of Texas at Austin</h3>

    </center>
    EE 306, Fall 2013<br>
    Problem Set 5<br>
    Due: 11 November, before class<br>
    Yale N. Patt, Instructor<br>
	 TAs: Ben Lin, Mochamad Asri, Ameya Chaudhari, Nikhil Garg, Lauren Guckert<br>
   	   Jack Koenig, Saijel Mokashi, Sruti Nuthalapati, Sparsh Singhai, Jiajun Wang<br>


	<p>
      Instructions:
      <br>
      You are encouraged to work on the problem set in groups and turn
      in one problem set for the entire group. Remember to put all
      your names on the solution sheet.  Also, remember to put the name
      of the TA and the time for the discussion section you would like the problem
      set turned back to you. Show your work. <br>
		<b>Please staple your Problem Sets BEFORE coming to class!</b><br>
    </p>
 
<br>
<ol>

<li><!-- Begin Question --> <font color =red> Moved from problem set 4 </font>
<ol type="a">
<li>
<p>Bob Computer just bought a fancy new graphics display
for his <abbr title="Little Computer 3">LC-3</abbr>. In order to test out how fast it is, he rewrote the <code>OUT</code> trap
handler so it would not check the <code>DSR</code> before outputting. Sadly he discovered
that his display was not fast enough to keep up with the speed at which the LC-3
was writing to the <code>DDR</code>. How was he able to tell?</p>

</li><li>
<p>Bob also rewrote the handler for <code>GETC</code>, but when he typed
<code>ABCD</code> into the keyboard, the following values were input:</p>
<pre><code>
AAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDD
</code></pre>
<p>What did Bob do wrong?</p>
</li>

</ol>

</li> <!-- End of Question --><br>

<li><!-- Begin Question --> <font color =red> Now moved to problem set 6 (Updated 11/06/2013) </font>
 (Adapted from 6.16) Shown below are the partial contents of memory locations x3000 to x3006.<br><br>

<table border="1" align="center" bordercolor="#000000" style="background-color:#FFFFFF" width="600" cellpadding="3" cellspacing="1">
	<tr align="center">

		<td>&nbsp; </td>
		<td>15</td>
		<td></td>
		<td></td>
		<td></td>		
		<td></td>
		<td></td>
		<td></td>

		<td></td>		
		<td></td>
		<td></td>
		<td></td>
		<td></td>		
		<td></td>
		<td></td>
		<td></td>
		<td>0</td>

	</tr>
	<tr align="center">
		<td>x3000</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

	</tr>
	<tr align="center">
		<td>x3001</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>1</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>
		<td>1</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>1</td>
	</tr>
	<tr align="center">
		<td>x3002</td>

		<td>1</td>
		<td>0</td>

		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
	</tr>
	<tr align="center">
		<td>x3003</td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
	</tr>
	<tr align="center">
		<td>x3004</td>
		<td>1</td>

		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>

		<td>1</td>
		<td>0</td>
		<td>1</td>
	</tr>
	<tr align="center">
		<td>x3005</td>

		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>

		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
	</tr>
	<tr align="center">

		<td>x3006</td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>

		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
		<td>&nbsp; </td>
	</tr>

</table>

<br><br>

The PC contains the value x3000, and the RUN button is pushed.<br><br>
As the program executes, we keep track of all values loaded into the MAR. Such a record is often referred to as an address trace. It is shown below. <br><br>
<center>
<u><b>MAR Trace <br></b></u>
  x3000<br>
  x3005<br>

  x3001<br>

  x3002<br>
  x3006<br>
  x4001<br>
  x3003<br>
  x0021<br><br>

</center>
Your job: Fill in the missing bits in memory locations x3000 to x3006.


</li> <!-- End of Question --><br><br>
<li><!-- Begin Question -->
<font color =red> Moved to problem set 6 (Updated 11/06/2013) </font>
<p>
Jane Computer (Bob's adoring wife), not to be outdone
by her husband, decided to rewrite the <code>TRAP x22</code> handler at a different place in
memory. Consider her implementation below. If a user writes a program that uses this


<code>TRAP</code> handler to output an array of characters, how many times is the <code>ADD</code>

instruction at the location with label <code>A</code> executed? Assume that the
user only calls this "new" <code>TRAP x22</code> once. What is wrong with this <code>TRAP</code> handler?
Now add the necessary instructions so the <code>TRAP</code> handler executes properly.</p>

<p>Hint: <code>RET</code> uses <code>R7</code> as linkage back to the caller
(<code>RET</code> is equivalent to <code>JMP R7</code>).</p>

<pre><code>
; TRAP handler
; Outputs ASCII characters stored in consecutive memory locations.
; R0 points to the first ASCII character before the new TRAP x22 is called.
; The null character (x00) provides a sentinel that terminates the output sequence.

        .ORIG x020F
START   LDR R1, R0, #0
        BRz DONE
        ST R0, SAVER0
        ADD R0, R1, #0
        TRAP x21
        LD R0, SAVER0
A       ADD R0, R0, #1
        BRnzp START
DONE    RET
 
SAVER0  .BLKW #1
        .END
</code></pre>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
<font color =red> Moved to problem set 6 (Updated 11/06/2013) </font>
(Adapted from 9.2) 
<ol type="a">

<li><p>How many <code>TRAP</code> service routines can be implemented in the LC-3? Why?</p></li>

<li><p>Why must a <code>RET</code> instruction be used to return from a <code>TRAP</code> routine? Why won't
a <code>BRnzp</code> (unconditional <code>BR</code>) instruction work instead?</p></li>

<li><p>How many accesses to memory are made during the processing of a <code>TRAP</code> instruction?</p></li>

</ol>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
<p>Assume that you have the following table in your program:</p>
<pre><code>
MASKS   .FILL x0001
        .FILL x0002
        .FILL x0004
        .FILL x0008
        .FILL x0010
        .FILL x0020
        .FILL x0040
        .FILL x0080
        .FILL x0100
        .FILL x0200
        .FILL x0400
        .FILL x0800
        .FILL x1000
        .FILL x2000
        .FILL x4000
        .FILL x8000
</code></pre>
<ol type="a">
<li>
<p>Write a subroutine <code>CLEAR</code> in LC-3 assembly language that clears
a bit in <code>R0</code> <em>using the table above</em>. The index of the bit
to clear is specified in <code>R1</code>. <code>R0</code> and <code>R1</code>
are inputs to the subroutine.</p>

</li>
<li>
<p>Write a similar subroutine <code>SET</code> that sets the specified bit instead of clearing it.</p>
</li>
<p>
Hint: You should remember to save and restore any registers your subroutine
uses (the "callee save" convention). Use the <code>RET</code> instruction as
the last instruction in your subroutine (<code>R7</code> contains the address
of where in the caller to return to.)
</p>
</ol>
</li><br/><!-- End of Question -->

<li><!-- Begin Question -->
<p>Suppose we are writing an algorithm to multiply the
elements of an array (unpacked, 16-bit 2's complement numbers), and we
are told that a subroutine "mult_all" exists which multiplies four
values, and returns the product.
The mult_all subroutine assumes the source operands are in R1, R2, R3,
R4, and returns the product in R0. For purposes of this assignment, let
us assume that the individual values are small enough that the result
will always fit in a 16-bit 2's complement register.</p>
<p>
Your job: Using this subroutine, write a program to multiply the set of
values contained in consecutive locations starting at location x6001.
The number of such values is contained in x6000. Store your result at location x7000. Assume there is at least one value in the array(i.e., M[x6000] is greater than 0).
</p><ol type="a">
<p>

Hint: Feel free to include in your program
</p><pre><code>
PTR	.FILL x6001
CNT	.FILL x6000
</code></pre><p></p>
</ol>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
(Adapted from 9.13)<br>The following program is supposed to
print the number 5 on the screen. It does not work. Why? Answer in no
more than ten words, please.
<pre><code>
	.ORIG 	x3000
	JSR	A
	OUT			;TRAP  x21
	BRnzp	DONE
A 	AND	R0,R0,#0
	ADD	R0,R0,#5
	JSR	B
	RET	
DONE	HALT
ASCII	.FILL	x0030
B	LD	R1,ASCII
	ADD	R0,R0,R1
	RET
	.END
</code></pre>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
<font color =red> Moved to problem set 6 (Updated 11/06/2013) </font>
(Adapted from 8.15)<br>
<ol type="a">
    <li>What does the following LC-3 program do?
<pre><code>
        .ORIG  x3000
        LD R3 , A
        STI R3, KBSR
AGAIN   LD R0,B
        TRAP X21
        BRnzp AGAIN
A       .FILL X4000
B       .FILL X0032
KBSR    .FILL XFE00
        .END
</code></pre>
    </li>
    <li> If someone strikes a key, the program will be interrupted and the
keyboard interrupt service routine will be executed as shown below.
What does the keyboard interrupt service routine do?
<pre><code>
        .ORIG X1000
        LDI R0,KBDR
        TRAP X21
        TRAP X21
        RTI
KBDR    .FILL XFE02
        .END
</code></pre>
</li>
<li>
Finally, suppose the program of part a started executing, and someone sitting at the keyboard struck a key. What would you see on the screen?
</li>
</ol>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
(Adapted from 8.16)<br>
What does the following LC-3 program do?
<pre><code>
        .ORIG X3000
        LD R0,ASCII
        LD R1,NEG
AGAIN   LDI R2,DSR
        BRzp AGAIN
        STI R0,DDR
        ADD R0,R0,#1
        ADD R2,R0,R1
        BRnp AGAIN
        HALT
ASCII   .FILL X0041
NEG     .FILL XFFB6
DSR     .FILL XFE04
DDR     .FILL XFE06
        .END
</code></pre>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
(Adapted from 9.5)<br>
The following LC-3 program is assembled and then executed. There are no assemble time or run-time errors. What is the output of this program?
Assume all registers are initialized to 0 before the program executes.
<pre><code>
        .ORIG X3000
        ST R0, X3007
        LEA R0, LABEL
        TRAP X22
        TRAP x25
LABEL   .STRINGZ "FUNKY"
LABEL2  .STRINGZ "HELLO WORLD"
        .END
</code></pre>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
The memory locations given below store students' exam scores in form of a linked list. Each node of the linked list uses three memory locations to store<br><br>
1. Address of the next node<br>
2. Starting address of the memory locations where name of the student is stored<br>
3. Starting address of the memory locations where the his/her exam score is stored<br><br>
in the given order. The first node is stored in locations x4000 ~ x4002. The ASCII code x0000 is used as a sentinel to indicate the end of the string. Both the name and exam score are stored as strings.<br>
Write down the student's name and score in the order that it appears in the list.

<pre><code>
    Address         Contents
    x4000           x4016
    x4001           x4003
    x4002           x4008
    x4003           x004D
    x4004           x0061
    x4005           x0072
    x4006           x0063
    x4007           x0000
    x4008           x0039
    x4009           x0030
    x400A           x0000
    x400B           x0000
    x400C           x4019
    x400D           x401E
    x400E           x004A
    x400F           x0061
    x4010           x0063
    x4011           x006B
    x4012           x0000
    x4013           x0031
    x4014           x0038
    x4015           x0000
    x4016           x400B
    x4017           x400E
    X4018           x4013
    x4019           x004D
    x401A           x0069
    x401B           x006B
    x401C           x0065
    x401D           x0000
    x401E           x0037
    x401F           x0036
    x4020           x0000
</code></pre>
</li><!-- End of Question --><br/>


<li><!-- Begin Question -->
	<ol type=a>
	  <li>The program below counts the number of zeros in a 16-bit word.  Fill in the missing blanks below to make it work.<br>
	    <pre>
            .ORIG x3000
            AND   R0, R0, #0
            LD    R1, SIXTEEN
            LD    R2, WORD
A           BRn   B
            ________________		
B           ________________
            BRz   C
            ________________	
            BR    A	; note: BR = BRnzp
C           ST    R0, RESULT
            HALT

SIXTEEN     .FILL #16
WORD        .BLKW #1
RESULT      .BLKW #1
            .END</pre></li>
	  <li>After you have the correct answer above, what one instruction can you change (without adding any instructions) 
	    that will make the program count the number of ones instead?</li>
	</ol>
</li> <!--	End of Question --> <br/>
	
<li><!-- Begin Question --> <font color =red> Added on 11/05/2013</font>

Suppose we use the unused opcode 1101 to specify a new instruction. We will require 3 states after decode (state 32) to complete the job. The control signals required to carry out the work of the new instruction are shown below. All control signals not shown below are 0.
<center>
	<img src=data_path.png width = 40%>
</center>
<ol type=a>
	<li> What does this new instruction do? </li>

	<li> There are two different formats for specifying the operands of this instruction. Fill them out below. </li>
	<center>
		<img src = inst_format.png width = 30%>
	</center>
</ol>

</li> <!--	End of Question --> <br/>
</ol></body></html>
