<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<style>
    body {background-color: white; color: black}
    h1, h2, h3 {text-align: center}
    p, li {orphans: 3; widows: 3}
    .figure {margin-top: 1em; margin-right: auto; margin-bottom: 1em; margin-left: auto; text-align: center}
    table {border-collapse: collapse; empty-cells: show; page-break-inside: avoid}
    td {border: 1px solid black; padding: 0.5em}
    th {border: 1px solid black; padding: 0.5em; font-weight: bold}
    code {font-family: monospace}
    ol {list-style-type: decimal; margin-top: .5em; margin-bottom: .5em}
    ol ol {list-style-type: lower-alpha}
  </style>

    <title>EE 306 - Problem Set 5</title>
  </head><body bgcolor="white">
    <center>
      <h2>Department of Electrical and Computer Engineering</h2>
      <h3>The University of Texas at Austin</h3>

    </center>
    EE 306, Fall 2014<br>
    Problem Set 5 Solution<br>
    Due: November 10th, before class<br>
    Aater Suleman, Instructor<br>
    TAs: Owais Khan, Cagri Eryilmaz and Chirag Sakhuja <br>

	<p>
      Instructions:
      <br>
      You are encouraged to work on the problem set in groups and turn
      in one problem set for the entire group. Remember to put all
      your names on the solution sheet.  Also, remember to put the name
      of the TA and the time for the discussion section you would like the problem
      set turned back to you. Show your work. <br>
    </p>

<br>
<ol>


<li><!-- Begin Question -->
(Adapted from 6.16) Shown below are the partial contents of memory locations x3000 to x3006.<br><br>

<table style="background-color: rgb(255, 255, 255);" width="600" align="center" border="1" bordercolor="#000000" cellpadding="3" cellspacing="1">
	<tbody><tr align="center">

		<td>&nbsp; </td>
		<td>15</td>
		<td></td>
		<td></td>
		<td></td>		
		<td></td>
		<td></td>
		<td></td>

		<td></td>		
		<td></td>
		<td></td>
		<td></td>
		<td></td>		
		<td></td>
		<td></td>
		<td></td>
		<td>0</td>

	</tr>
	<tr align="center">
		<td>x3000</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td><b>0</b> </td>
		<td><b>0</b> </td>
		<td><b>0</b> </td>

		<td><b>0</b> </td>
		<td><b>0</b> </td>
		<td><b>0</b> </td>
		<td><b>1</b> </td>
		<td><b>0</b> </td>
		<td><b>0</b> </td>

	</tr>
	<tr align="center">
		<td>x3001</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>1</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>
		<td>1</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>1</td>
	</tr>
	<tr align="center">
		<td>x3002</td>

		<td>1</td>
		<td>0</td>

		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td><b>0 </td>

		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>0 </td>

		<td><b>1 </td>
		<td><b>1 </td>
	</tr>
	<tr align="center">
		<td>x3003</td>
		<td><b>1</td>
		<td><b>1</td>

		<td><b>1</td>
		<td><b>1</td>
		<td><b>0</td>
		<td><b>0</td>
		<td><b>0</td>
		<td><b>0</td>

		<td><b>0</td>
		<td><b>0</td>
		<td><b>1</td>
		<td><b>0</td>
		<td><b>0</td>
		<td><b>0</td>

		<td><b>0</td>
		<td><b>1</td>
	</tr>
	<tr align="center">
		<td>x3004</td>
		<td>1</td>

		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>

		<td>1</td>
		<td>0</td>
		<td>1</td>
	</tr>
	<tr align="center">
		<td>x3005</td>

		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>

		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>1</td>
		<td>1</td>

		<td>0</td>

		<td>0</td>
		<td>0</td>
		<td>0</td>
	</tr>
	<tr align="center">

		<td>x3006</td>
		<td><b>0 </td>
		<td><b>1 </td>
		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>0 </td>

		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>0 </td>

		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>0 </td>
		<td><b>1 </td>
	</tr>

</tbody></table>

<br><br>

The PC contains the value x3000, and the RUN button is pushed.<br><br>
As the program executes, we keep track of all values loaded into the
MAR. Such a record is often referred to as an address trace. It is
shown below. <br><br>
<center>
<u><b>MAR Trace <br></b></u>
  x3000<br>
  x3005<br>

  x3001<br>

  x3002<br>
  x3006<br>
  x4001<br>
  x3003<br>
  x0021<br><br>

</center>
Your job: Fill in the missing bits in memory locations x3000 to x3006.


</li> <!-- End of Question --><br><br>

<li><!-- Begin Question -->
(Adapted from 9.2)
<ol type="a">

<li><p>How many <code>TRAP</code> service routines can be implemented in the LC-3? Why?</p></li>

<li><p>Why must a <code>RET</code> instruction be used to return from a <code>TRAP</code> routine? Why won't
a <code>BRnzp</code> (unconditional <code>BR</code>) instruction work instead?</p></li>

<li><p>How many accesses to memory are made during the processing of a <code>TRAP</code> instruction?</p></li>

</ol>
<font>
<b>
Solution: <br><br>

a. 256 TRAP service routines can be implemented. x0000- x00FF<br><br>
b.
	RET stores the value of PC (before execution of the service routine) in R7 so that it can return control to the original program after execution of the service routine.
         A BRnzp would not work because:<br>
              - the TRAP routine may not be reached by a 9 bit offset.<br>
              - if TRAP is called multiple times, the computer would not know which LABEL to go to
                  (can change every time).<br><br>
c.     2 memory accesses are made during TRAP instruction<br>
         1st access:- instruction in fetch <br>
         2nd access:- trap vector table to get address of TRAP service routine <br>
</b>
</font>

</li><br/>


</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
<p>Assume that you have the following table in your program:</p>
<pre><code>
MASKS	.FILL x0001
	.FILL x0002
	.FILL x0004
	.FILL x0008
	.FILL x0010
	.FILL x0020
	.FILL x0040
	.FILL x0080
	.FILL x0100
	.FILL x0200
	.FILL x0400
	.FILL x0800
	.FILL x1000
	.FILL x2000
	.FILL x4000
	.FILL x8000
</code></pre>
<ol type="a">
<li>
<p>Write a subroutine <code>CLEAR</code> in LC-3 assembly language that clears
a bit in <code>R0</code> <em>using the table above</em>. The index of the bit
to clear is specified in <code>R1</code>. <code>R0</code> and <code>R1</code>
are inputs to the subroutine.</p>

<font><b>
Solution:
<pre><code>
        CLEAR: ST R2, TEMP
	       LEA R2, MASKS
	       ADD R2,R1,R2
	       LDR R2,R2,#0
	       NOT R2,R2
	       AND R0,R2,R0
	       LD R2, TEMP
	       RET
	TEMP:  .BLKW #1
	</code>
	</pre> 
</b>
</font>

</li>
<li>
<p>Write a similar subroutine <code>SET</code> that sets the specified bit instead of clearing it.</p>
<b>
Solution:
	<pre><code>
	SET:   ST R2, TEMP
	       LEA R2, MASKS
	       ADD R2,R1,R2
	       LDR R2,R2,#0
	       NOT R2,R2
	       NOT R0,R0
	       AND R0,R2,R0
	       NOT R0,R0
	       LD R2, TEMP
	       RET
	TEMP:  .BLKW #1
	</code>
	</pre> 
</b>

</li>
<p>
Hint: You should remember to save and restore any registers your subroutine
uses (the "callee save" convention). Use the <code>RET</code> instruction as
the last instruction in your subroutine (<code>R7</code> contains the address
of where in the caller to return to.)
</p>
</ol>
</li><br/><!-- End of Question -->

<li><!-- Begin Question -->
<p>Suppose we are writing an algorithm to multiply the
elements of an array (unpacked, 16-bit 2's complement numbers), and we
are told that a subroutine "mult_all" exists which multiplies four
values, and returns the product.
The mult_all subroutine assumes the source operands are in R1, R2, R3,
R4, and returns the product in R0. For purposes of this assignment, let
us assume that the individual values are small enough that the result
will always fit in a 16-bit 2's complement register.</p>
<p>
Your job: Using this subroutine, write a program to multiply the set of
values contained in consecutive locations starting at location x6001.
The number of such values is contained in x6000. Store your result at location x7000. Assume there is at least one value in the array(i.e., M[x6000] is greater than 0).
</p><ol type="a">
<p>

Hint: Feel free to include in your program
</p><pre><code>
PTR	.FILL x6001
CNT	.FILL x6000
</code></pre><p></p>

<font ><b>
Solution: <br>
<pre>
<code>
      .ORIG x3000
      LD R5, PTR
      LDI R6, CNT
      BRz DONEz    ;checks if more numbers to multiply(CNT=0)
MORE  LDR R1,R5,#0
      ADD R5,R5,#1
      ADD R6,R6,#-1
      BRz DONE1    ;continues if more numbers to multiply
      LDR R2,R5,#0       ;
      ADD R5,R5,#1
      ADD R6,R6,#-1
      BRz DONE2    ;continues if more numbers to multiply
      LDR R3,R5,#0
      ADD R5,R5,#1
      ADD R6,R6,#-1
      BRz DONE3    ;continues if more numbers to multiply
      LDR R4,R5,#0
      ADD R5,R5,#1
      ADD R6,R6,#-1
      BRnzp READY ;CNT is multiple of 4
DONEz AND R0,R0,#0
      ADD R0,R0,#1
      BRnzp END

;(CNT = 4x+1) multiplies R1 by three 1's
DONE1 AND R2,R2,#0
      ADD R2,R2,#1       ;R2 = 1
      ADD R3,R2,#0       ;R3 = 1
      ADD R4,R2,#0       ;R4 = 1
      BRnzp READY

;(CNT = 4x+2) multiplies R1,R2 by two 1's
DONE2 AND R3,R3,#0
      ADD R3,R3,#1       ;R3 = 1
      ADD R4,R4,#0       ;R4 = 1
      BRnzp READY
;
;(CNT = 4x+3) multiplies R1,R2,R3 by 1
DONE3 AND R4,R4,#0
      ADD R4,R4,#1
READY JSR mult_all
      ADD R6,R6,#0
      BRz END            ;checks CNT
;
;if CNT is not zero takes R0 from subroutine and puts back into
memory to multiply more numbers
       ADD R5,R5,#-1
       STR R0,R5,#0
;add one back to CNT because R0 is back into memory
       ADD R6,R6,#1
       BRnzp MORE
;
;store result of multiplication in memory location RESULT
END    ST R0,RESULT
       HALT
RESULT        .BLKW 1
mult_all ... ;multiples R1,R2,R3,R4 and stores result in R0
            ...
            ...
            RET
PTR    .FILL x6001
CNT    .FILL x6000
.END
</code>
</pre></b>
</font>

</ol>
</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
(Adapted from 9.13)<br>The following program is supposed to
print the number 5 on the screen. It does not work. Why? Answer in no
more than ten words, please.
<pre><code>
	.ORIG	x3000
	JSR	A
	OUT			;TRAP  x21
	BRnzp	DONE
A	AND	R0,R0,#0
	ADD	R0,R0,#5
	JSR	B
	RET
DONE	HALT
ASCII	.FILL	x0030
B	LD	R1,ASCII
	ADD	R0,R0,R1
	RET
	.END
</code></pre>
<font > <b>Solution: <br>  Need to save R7 so 1st service routine can return. Second RET overwrites the first RET value.<br><br></b>
</font>

</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
(Adapted from 8.16)<br>
What does the following LC-3 program do?
<pre><code>
	.ORIG X3000
	LD R0,ASCII
	LD R1,NEG
AGAIN	LDI R2,DSR
	BRzp AGAIN
	STI R0,DDR
	ADD R0,R0,#1
	ADD R2,R0,R1
	BRnp AGAIN
	HALT
ASCII	.FILL X0041
NEG	.FILL XFFB6
DSR	.FILL XFE04
DDR	.FILL XFE06
	.END
</code></pre>

<b> Solution<br>
Letter ABCDEFGHI will be displayed on console.
</b>

</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
(Adapted from 9.5)<br>
The following LC-3 program is assembled and then executed. There are no assemble time or run-time errors. What is the output of this program?
Assume all registers are initialized to 0 before the program executes.
<pre><code>
	.ORIG X3000
	ST R0, X3007
	LEA R0, LABEL
	TRAP X22
	TRAP x25
LABEL	.STRINGZ "FUNKY"
LABEL2	.STRINGZ "HELLO WORLD"
	.END
</code></pre>
<b> Solution <br> 
    FUN
</b>

</li><!-- End of Question --><br/>

<li><!-- Begin Question -->
The memory locations given below store students' exam scores in form of a linked list. Each node of the linked list uses three memory locations to store<br><br>
1. Address of the next node<br>
2. Starting address of the memory locations where name of the student is stored<br>
3. Starting address of the memory locations where the his/her exam score is stored<br><br>
in the given order. The first node is stored in locations x4000 ~ x4002. The ASCII code x0000 is used as a sentinel to indicate the end of the string. Both the name and exam score are stored as strings.<br>
Write down the student's name and score in the order that it appears in the list.

<pre><code>
    Address	    Contents
    x4000	    x4016
    x4001	    x4003
    x4002	    x4008
    x4003	    x004D
    x4004	    x0061
    x4005	    x0072
    x4006	    x0063
    x4007	    x0000
    x4008	    x0039
    x4009	    x0030
    x400A	    x0000
    x400B	    x0000
    x400C	    x4019
    x400D	    x401E
    x400E	    x004A
    x400F	    x0061
    x4010	    x0063
    x4011	    x006B
    x4012	    x0000
    x4013	    x0031
    x4014	    x0038
    x4015	    x0000
    x4016	    x400B
    x4017	    x400E
    X4018	    x4013
    x4019	    x004D
    x401A	    x0069
    x401B	    x006B
    x401C	    x0065
    x401D	    x0000
    x401E	    x0037
    x401F	    x0036
    x4020	    x0000
</code></pre>
<font><b>
Solution:<br>
 
Marc	90 <br>
Jack	18 <br>
Mike	76 <br>
</b>

</li><!-- End of Question --><br/>


<li><!-- Begin Question -->
	<ol type=a>
	  <li>The program below counts the number of zeros in a 16-bit word.  Fill in the missing blanks below to make it work.<br>
	    <pre>
	    .ORIG x3000
	    AND   R0, R0, #0
	    LD	  R1, SIXTEEN
	    LD	  R2, WORD
A	    BRn   B
            <FONT COLOR="#0000ff">ADD   R0, R0, #1</FONT>
B           <FONT COLOR="#0000ff">ADD   R1, R1, #-1</FONT>
	    BRz   C
            <FONT COLOR="#0000ff">ADD   R2, R2, R2</FONT>
	    BR	  A	; note: BR = BRnzp
C	    ST	  R0, RESULT
	    HALT

SIXTEEN     .FILL #16
WORD	    .BLKW #1
RESULT	    .BLKW #1
	    .END</pre></li>
	  <li>After you have the correct answer above, what one instruction can you change (without adding any instructions)
	    that will make the program count the number of ones instead?</li>
	</ol>
</li> <!--	End of Question --> <br/>

<li><!-- Begin Question --> 

Suppose we use the unused opcode 1101 to specify a new instruction. We will require 3 states after decode (state 32) to complete the job. The control signals required to carry out the work of the new instruction are shown below. All control signals not shown below are 0.
<center>
	<img src=data_path.png width = 40%>
</center>
<ol type=a>
	<li> What does this new instruction do? </li>
	<b>
		Adds contents of SR1 (IR[8:6]) to SR2 (or immediate) and store the result in location specified by BaseR (IR[11:9]).  
	</b>

	<li> There are two different formats for specifying the operands of this instruction. Fill them out below. </li>
	<center>
		<img src = inst_format_sol.png width = 30%>
	</center>
</ol>

</li> <!--	End of Question --> <br/>
</ol></body></html>
